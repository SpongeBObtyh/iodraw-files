{"root":{"data":{"id":"d66zksi8m5c0","created":1733728828512,"text":"java 锁的分类"},"children":[{"data":{"id":"d66zl3pyqa80","created":1733728852924,"text":"公平锁和非公平锁","layout_mind_offset":{"x":66,"y":25},"note":"大概意思是获取锁是否遵循先来后到的原则"},"children":[]},{"data":{"id":"d66zsaawx7k0","created":1733729415800,"text":"可重入锁和非重入锁","layout_mind_offset":{"x":69,"y":40},"note":"可重入锁：方法1调用方法2的时候，如果方法1使用了可重入锁，那么在调用方法2的时候不需要再次等待方法1锁的释放和获取。\n非可重入锁：方法1调用方法2，在方法2执行的时候会等待方法1所拥有锁的释放后再次获取。"},"children":[{"data":{"id":"d68n45wy3pk0","created":1733896792103,"text":"可重入锁","note":"ReentrantLock：\nsynchronized：\n\nReentrantLock 是一个类，而 synchronized 是 Java 中的关键字；\nReentrantLock 可以实现多路选择通知（可以绑定多个 Condition），而 synchronized 只能通过 wait 和 notify/notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知）；\nReentrantLock 必须手动释放锁。通常需要在 finally 块中调用 unlock 方法以确保锁被正确释放。\nsynchronized 会自动释放锁，当同步块执行完毕时，由 JVM 自动释放，不需要手动操作。\nReentrantLock: 通常提供更好的性能，特别是在高竞争环境下。\nsynchronized: 在某些情况下，性能可能稍差一些，但随着 JDK 版本的升级，性能差距已经不大了。"},"children":[]},{"data":{"id":"d68n4ugwrm00","created":1733896845553,"text":"非可重入锁","note":"NonReentrantLock:"},"children":[]}]},{"data":{"id":"d66zsdb73zk0","created":1733729422348,"text":"读写锁和排他锁","layout_mind_offset":{"x":665,"y":-95},"note":"排他锁：锁在同一时刻只允许一个线程进行访问，如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程既能读数据又能修改数据。\n读写锁：同一时刻允许多个读线程访问"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}